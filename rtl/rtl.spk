
class Object : null {
    self == x { return self === x; }
    self != x { return self !== x; }
    printString { return "<XXX Object printString>"; }    
    extern unboxed {}
} meta {
    self new { return self basicNew; }
    self new: anInteger { return self basicNew: anInteger; }
    self basicNew { return self basicNew: 0; }
    extern self basicNew: anInteger {}
    extern self box: aPointer {}
}


class Array : Object {
    obj size;
    
    // initializing
    extern self init: anInteger {}
    extern self initWithContentsOfStack: end {}
    
    // accessing
    extern size {}
    extern self[i] {}
    extern self[i] = v {}
    
    printString {
        obj i, s, result;
        
        s = self.size;
        if (s == 0)
            return "{}";
        result = "{ ";
        for (i = 0; i < s; ++i) {
            result += self[i].printString;
            if (i + 1 < s)
                result += ", ";
        }
        result += " }";
        return result;
    }
    
    // enumerating
    self do: aBlock { obj i, s; s = self.size; for (i = 0; i < s; ++i) aBlock(self[i]); }
    
} meta {
    self new { return self new: 0; }
    self new: size { return (self basicNew: size) init: size; }
    self withContentsOfStack: end size: size { return (self new: size) initWithContentsOfStack: end; }
}


class Behavior : Object {
    obj superclass;
    obj rvMethodTable;
    obj lvMethodTable;
    obj instVarCount;
    
    superclass { return superclass; }
}


// XXX
class Char : Object {
    obj value;
    extern unboxed {}
}


class Class : Behavior {
    obj name;
    
    name { return name; }
}


class IdentityDictionary : Object {
    size { /* XXX */ }
    self[k] { /* XXX */ }
    self[k] = v { /* XXX */ }
    get(k) { /* XXX */ }
}



// class Float : Object


class Integer : Object {
    
    // unary operators
    extern self + 1 {}
    extern self - 1 {}
    extern +self    {}
    extern -self    {}
    extern ~self    {}
    
    // binary operators
    extern self * x {}
    extern self / x {}
    extern self % x {}
    extern self + x {}
    extern self - x {}
    extern self << x {}
    extern self >> x {}
    extern self & x {}
    extern self ^ x {}
    extern self | x {}
    
    // comparison operators
    extern self < x {}
    extern self > x {}
    extern self <= x {}
    extern self >= x {}
    extern self == x {}
    extern self != x {}
    
    // unboxing
    extern unboxed {}
    
    // printing
    printString { return String fromInteger: self; }
    
} meta {
    extern self box: aPointer {}
}


class Metaclass : Behavior {
    obj thisClass;
    
    new { /* XXX ??? */ }
}


class String : Object {
    obj size;
    // str...
    
    // binary operators
    self + x { return String_add(self.asCObject, x.asCObject); }
    
    // comparison operators
    self <  x { return String_lt(self.asCObject, x.asCObject); }
    self >  x { return String_gt(self.asCObject, x.asCObject); }
    self <= x { return String_le(self.asCObject, x.asCObject); }
    self >= x { return String_ge(self.asCObject, x.asCObject); }
    self == x { return String_eq(self.asCObject, x.asCObject); }
    self != x { return String_ne(self.asCObject, x.asCObject); }
    
    // accessing
    size { return String_size(self.asCObject); }
    len { return self.size; }
    self[i] { return String_item(self.asCObject, i); }
    printString { return String_printString(self.asCObject); }
    
    // enumerating
    self do: aBlock { obj i, s; s = self.size; for (i = 0; i < s; ++i) aBlock(self[i]); }
    
    // unboxing
    extern unboxed {}
    extern asCObject {} // to suppress unboxing
    
} meta {
    
    self fromInteger: anInteger { return String_fromInteger(anInteger); }

}


class Symbol : Object {
    obj hash;
    // str...
    
    printString { return Symbol_printString(self); }
}


class Boolean {
    !self    { self subclassResponsibility; }
    ~self    { self subclassResponsibility; }
    self & x { self subclassResponsibility; }
    self ^ x { self subclassResponsibility; }
    self | x { self subclassResponsibility; }
}

class False : Boolean {
    !self    { return true; }
    ~self    { return true; }
    self & x { return false; }
    self ^ x { return x; }
    self | x { return x; }
}

class True : Boolean {
    !self    { return false; }
    ~self    { return false; }
    self & x { return x; }
    self ^ x { return !x; }
    self | x { return true; }
}


class Method : Object {
    obj minArgumentCount;
    obj maxArgumentCount;
    obj localCount;
    // code...
}

class Function : Method {
    extern self( /*...args*/ ) {}
}


class Context : Object {
    obj homeContext;
}

class MethodContext : Context {
    obj methodClass;
    obj receiver;
    obj instVarPointer;
    obj stackp;
}

class BlockContext : Context {
    obj nargs;
    obj pc;
    
    extern self( /*...args*/ ) {}
}


class CObject : Object {
    extern unboxed {}
}

class CFunction : Object {
    obj signature;
    obj pointer;
    
    extern self( /*...args*/ ) {}
    extern unboxed {}
}


class Message : Object {
    obj ns;
    obj selector;
    obj arguments;
    
    selector { return selector; }
    arguments { return arguments; }
}


class Null : Object {
    printString { return "null"; }
}

class Void : Object {
    printString { return "void"; }
}


// This is here just to make the compiler generate symbols.
class Junk {
    __ind__ {}
    __addr__ {}
    
    typeError {}
    rangeError {}
    mustBeBoolean{}
    badObjectPointer {}
    self doesNotUnderstand: aMessage {}
    cannotReenterBlock {}
    wrongNumberOfArguments {}
 }


extern cdecl obj String_add(s1, s2) {}
extern cdecl obj String_lt(s1, s2) {}
extern cdecl obj String_gt(s1, s2) {}
extern cdecl obj String_le(s1, s2) {}
extern cdecl obj String_ge(s1, s2) {}
extern cdecl obj String_eq(s1, s2) {}
extern cdecl obj String_ne(s1, s2) {}
extern cdecl int String_size(s) {}
extern cdecl obj String_item(s, i) {}
extern cdecl obj String_printString(s) {}
extern cdecl obj String_fromInteger(i) {}

extern cdecl obj Symbol_printString(s) {}
